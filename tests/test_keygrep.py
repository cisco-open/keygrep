#!/usr/bin/env python3
"""Keygrep tests"""

import os
import json
import subprocess
from pathlib import Path
from keygrep.keychain import KeyChain
from keygrep.keygrep_utility import get_privkey_data, dsa_key_support, NumericOpen
from keygrep.types import StrPath

def get_fpr(path: StrPath) -> str:
    """Get the SHA256 fingerprint of the ssh key at the given path"""
    keygen_process = subprocess.run(["ssh-keygen", "-l", "-f", Path(path)], capture_output=True, text=True, check=False)
    return " ".join(keygen_process.stdout.split(" ")[1:2])

def test_cli(tmp_path: Path) -> None:
    """Test that expected files are generated by CLI invocation."""
    subprocess.run(["keygrep", "-p", Path(__file__).parent / "test-keys" / "openssh", tmp_path],
                                     capture_output=True, check=False)

    assert set(os.listdir(tmp_path)) == {"private", "public", "private.csv",
                                         "private.json", "public.json"}

def test_numeric_open(tmp_path: Path) -> None:
    """Test various cases of NumericOpen()."""

    max_len = os.pathconf(tmp_path, "PC_NAME_MAX")

    filenames = [
        "A" * max_len,
        "A" * max_len,  # Duplicate should truncate two characters and append "-2"
        "/foo/bar/",    # Flatten
        "%41",          # Decode
        "ÃÃÃ"           # Normalize
    ]

    for filename in filenames:
        with NumericOpen(filename, tmp_path) as outf:
            outf.write("")

    assert set(os.listdir(tmp_path)) == {"A" * max_len,
                                         "A" * (max_len - 2) + "-2",
                                         "_foo_bar_",
                                         "A",
                                         "AAA",
                                        }

def test_doubled_header(tmp_path: Path) -> None:
    """Test that keys are detected in files with superfluous BEGIN blocks."""
    kc = KeyChain(output_dir=tmp_path, path_prefix=Path(__file__).parent, include_mangled=False)
    kc.load_private_keys(Path(__file__).parent / "test-keys/doubled_header")
    assert kc.private_keys[0]["sha256"] == "SHA256:l6itGumSMcRBBAFteCgmjQBIXqLK/jFGUH3viHX1RmE"

def test_public_key_dump(tmp_path: Path) -> None:
    """Test that public keys are correctly dumped."""
    kc = KeyChain(output_dir=tmp_path, path_prefix=Path(__file__).parent, include_mangled=False)
    kc.load_public_keys(Path(__file__).parent / "test-keys/multiple_keys.pub")
    kc.write_public_keys()

    assert set(os.listdir(tmp_path / "public")) == {"test-keys_multiple_keys.pub", "test-keys_multiple_keys.pub-2"}
    assert get_fpr(tmp_path / "public" / "test-keys_multiple_keys.pub") == "SHA256:l6itGumSMcRBBAFteCgmjQBIXqLK/jFGUH3viHX1RmE"
    assert get_fpr(tmp_path / "public" / "test-keys_multiple_keys.pub-2") == "SHA256:NoQh0XBUuYUSWqnzOzOBnfpgJTRWLMj7BlWAb8IbjeE"

def test_private_key_dump(tmp_path: Path) -> None:
    """Test that private keys are correctly dumped."""
    kc = KeyChain(output_dir=tmp_path, path_prefix=Path(__file__).parent, include_mangled=False)
    kc.load_private_keys(Path(__file__).parent / "test-keys/multiple_keys")
    kc.write_private_keys()

    assert set(os.listdir(tmp_path / "private")) == {"test-keys_multiple_keys", "test-keys_multiple_keys-2"}
    assert get_fpr(tmp_path / "private" / "test-keys_multiple_keys") == "SHA256:l6itGumSMcRBBAFteCgmjQBIXqLK/jFGUH3viHX1RmE"
    assert get_fpr(tmp_path / "private" / "test-keys_multiple_keys-2") == "SHA256:NoQh0XBUuYUSWqnzOzOBnfpgJTRWLMj7BlWAb8IbjeE"

def test_correlation(tmp_path: Path) -> None:
    """Test that private keys are correctly associated with public keys."""
    kc = KeyChain(output_dir=tmp_path, path_prefix="", include_mangled=False)
    kc.load_private_keys(Path(__file__).parent / "test-keys/openssh/ed25519_1")
    kc.load_public_keys(Path(__file__).parent / "test-keys/openssh/ed25519_1.pub")
    kc.correlate_keys()

    assert Path(list(kc.private_keys[0]["pubkey_locations"])[0]).name == "ed25519_1.pub"

def test_unmangling(tmp_path: Path) -> None:
    """Test unmangling rules."""
    kc = KeyChain(output_dir=tmp_path, path_prefix="", include_mangled=False)
    kc.load_private_keys(Path(__file__).parent / "test-keys/recoverable_ed25519_1")

    assert {t["sha256"] for t in kc.private_keys} == {"SHA256:L3k/oJubblSY0lB9Ulsl7emDMnRPKm/8udf2ccwk560"}
    assert list(kc.private_keys[0]["privkey_locations"].values()) == [[72, 493, 951]]

def test_viminfo_unmangling(tmp_path: Path) -> None:
    """Test .viminfo unmangling rules."""
    kc = KeyChain(output_dir=tmp_path, path_prefix="", include_mangled=False)
    kc.load_private_keys(Path(__file__).parent / "test-keys/viminfo")

    assert {t["sha256"] for t in kc.private_keys} == {"SHA256:L3k/oJubblSY0lB9Ulsl7emDMnRPKm/8udf2ccwk560",
                                                      "SHA256:l6itGumSMcRBBAFteCgmjQBIXqLK/jFGUH3viHX1RmE"}

    for private_key in kc.private_keys:
        if private_key["sha256"] == "SHA256:L3k/oJubblSY0lB9Ulsl7emDMnRPKm/8udf2ccwk560":
            assert list(private_key["privkey_locations"].values()) == [[446, 888]]
        if private_key["sha256"] == "SHA256:l6itGumSMcRBBAFteCgmjQBIXqLK/jFGUH3viHX1RmE":
            assert list(private_key["privkey_locations"].values()) == [[1323, 2251]]

def test_fingerprints(tmp_path: Path) -> None:
    """Test that fingerprints are correctly generated."""

    files = ["ecdsa_1", "ecdsa_2", "ecdsa_sk1", "ecdsa_sk2", "ed25519_1",
             "ed25519_2", "ed25519_sk1", "ed25519_sk2", "rsa_1", "rsa_2"]

    if dsa_key_support():
        files.extend(["dsa_1", "dsa_2"])

    kc = KeyChain(output_dir=tmp_path)

    for file in files:
        kc.load_private_keys(Path(__file__).parent / "test-keys/openssh" / file)

        with open(Path(__file__).parent / "test-keys/openssh" / f"{file}.fp", "r", encoding="utf-8") as fp_file:
            assert kc.private_keys[-1].get("sha256") == fp_file.read().strip()

def test_identical_keys(tmp_path: Path) -> None:
    """Test that for both public and private keys, keys with the same
    fingerprint are considered the same key."""
    test_data_dir = Path(__file__).parent / "test-keys/identical-keys"
    kc = KeyChain(output_dir=tmp_path)
    kc.load_private_keys(test_data_dir)

    assert len(kc.private_keys) == 1
    assert len(kc.private_keys[0]["privkey_locations"]) == 5

def test_invalid_public_keys(tmp_path: Path) -> None:
    """Test that distinct invalid public keys are tracked."""

    kc = KeyChain(output_dir=tmp_path, path_prefix="", include_mangled=True)
    kc.load_public_keys(Path(__file__).parent / "test-keys/bad-keys")
    assert len(kc.public_keys) == 2

def test_openssh_keys(tmp_path: Path) -> None:
    """Test that the expected results are written to private.json for OpenSSH
    test keys."""

    kc = KeyChain(output_dir=tmp_path, path_prefix="", include_mangled=False)
    kc.load_private_keys(Path(__file__).parent / "test-keys/openssh")
    kc.load_public_keys(Path(__file__).parent / "test-keys/openssh")
    kc.write_summary()

    with open(tmp_path / "private.json", "r", encoding="utf-8") as inf:
        priv_data = json.load(inf)

    # There should be 26 total instances of 15 distinct private keys.
    # 2 are distinct DSA keys, so without DSA support, 13 keys
    # should be identified when include_mangled=False
    assert len(priv_data) in (13, 15)

    n = 0
    for key in priv_data:
        # Note that each of these is actually a list of positions in the file where
        # the key was found. For this test data, there's only one key per file
        n+=len(key["privkey_locations"])

    # There are 4 DSA key files (dsa_1, dsa_2, dsa_n, dsa_n_pw) so 22 total keys without DSA support
    if dsa_key_support():
        assert n == 26
    else:
        assert n == 22

    for key in priv_data:
        # For OpenSSH formatted encrypted private keys, we can obtain the fingerprint and public key without the passphrase
        if "ENCRYPTED" not in key["priv"]:
            assert key["pub"] is not None
            assert key["sha256"] is not None
        # For PEM/PKCS8 formatted encrypted private keys, we cannot obtain the fingerprint or public key without the passphrase
        else:
            assert key["pub"] is None
            assert key["sha256"] is None

    with open(tmp_path / "public.json", "r", encoding="utf-8") as inf:
        pub_data = json.load(inf)

    # There should be 22 copies of 12 distinct public keys, or 19 and 10 if no DSA support
    # dsa_1.pub, dsa_1-cert.pub, dsa_2.pub

    if dsa_key_support():
        assert len(pub_data) == 12
    else:
        assert len(pub_data) == 10

    # Note that the reason there are 15 "distinct" private keys and only 12
    # public keys is that rsa_1_pw, ecdsa_1_pw, and dsa_1_pw are encrypted PEM
    # files. This means the entire file, including the public key portion, is
    # encrypted. We therefore cannot determine their fingerprints and so
    # must treat them as distinct private keys.

    n = 0

    for key in pub_data:
        # Note that each of these is actually a list of positions in the file where
        # the key was found. For this test data, there's only one key per file
        n+=len(key["pubkey_locations"])

    if dsa_key_support():
        assert n == 22
    else:
        assert n == 19

    # If include_mangled is False, we should always have a public key string
    # and fingerprint for each public key
    for key in pub_data:
        assert key["pub"] is not None
        assert key["sha256"] is not None

def test_encrypted_and_clear(tmp_path: Path) -> None:
    """Check that cleartext keys replace encrypted keys if we have copies of
    both."""

    kc = KeyChain(output_dir=tmp_path, path_prefix="", include_mangled=False)
    # Load encrypted first, in a format where we can obtain the fingerprint
    kc.load_private_keys(Path(__file__).parent / "test-keys/openssh/ed25519_1_pw")
    # Load a cleartext copy of the same key
    kc.load_private_keys(Path(__file__).parent / "test-keys/openssh/ed25519_1")
    kc.write_summary()

    assert kc.private_keys[0]["encrypted"] is False
    assert get_privkey_data(kc.private_keys[0]["priv"])["encrypted"] is False
